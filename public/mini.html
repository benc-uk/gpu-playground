<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Single Page GPU Raytracer</title>
  </head>
  <body style="margin: 0">
    <canvas style="width: 100%"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twgl.js/4.19.5/twgl.min.js"></script>
    <script id="vs" type="x-shader/x-vertex">
      #version 300 es
      in vec4 position;
      void main() {
        gl_Position = position;
      }
    </script>
    <script id="fs" type="x-shader/x-fragment">
      #version 300 es
      precision highp float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_aspect;
      out vec4 fragColor;

      struct Sphere {
        vec3 position;
        float radius;
        vec3 color;
        float hardness;
      };

      float sphereHit(vec3 ro, vec3 rd, Sphere sph) {
        vec3 oc = ro - sph.position;
        float b = dot(oc, rd);
        float c = dot(oc, oc) - sph.radius * sph.radius;
        float h = b * b - c;
        if (h < 0.0) return -1.0;
        return -b - sqrt(h);
      }

      vec3 lightPos = vec3(17.0, 17.0, 8.0);
      vec3 bgColor = vec3(0.0);
      float ambient = 0.04;

      const int numSpheres = 3;
      Sphere scene[numSpheres];
      scene[0] = Sphere(vec3(0.0, 0.0, 0.0), 2, vec3(0.8, 0.1, 0.0), 25.0);
      scene[1] = Sphere(vec3(0.0, 0.0, 0.0), 2, vec3(0.8, 0.1, 0.0), 25.0);
      scene[2] = Sphere(vec3(0.0, 0.0, 0.0), 2, vec3(0.8, 0.1, 0.0), 25.0);

      int hitIndex = -1;

      void main() {
        vec2 screenPos = gl_FragCoord.xy / u_resolution.xy;
        screenPos.x = (screenPos.x * u_aspect) - ((u_aspect - 1.0) / 2.0);

        vec3 ro = vec3(0.0, 0.0, 10.0);
        vec3 rd = normalize(vec3(screenPos - 0.5, -1.0));

        float minT = 1e9;
        for (int i = 0; i < numSpheres; i++) {
          float t = sphereHit(ro, rd, scene[i]);
          if (t > 0.0 && t < minT) {
            minT = t;
            hitIndex = i;
          }
        }

        vec3 color = bgColor;
        if (hitIndex >= 0) {
          Sphere hitSphere = scene[hitIndex];

          vec3 pos = ro + rd * minT;
          vec3 normal = normalize(pos - hitSphere.position);
          vec3 lightDir = normalize(lightPos - pos);
          float diff = max(dot(normal, lightDir), 0.0);
          float specular = pow(max(dot(reflect(-lightDir, normal), -rd), 0.0), hitSphere.hardness);

          float shadowT = 1e9;
          for (int i = 0; i < numSpheres; i++) {
            if (i == hitIndex) continue;
            float t = sphereHit(pos + normal * 0.001, lightDir, scene[i]);
            if (t > 0.0 && t < shadowT) {
              shadowT = t;
            }
          }
          if (shadowT < 1e8) {
            diff *= 0.1;
            specular = 0.0;
          }

          color = hitSphere.color * diff + ambient + specular;
        }

        fragColor = vec4(color, 1.0);
      }
    </script>
    <script>
      const gl = document.querySelector('canvas').getContext('webgl2')
      const progInfo = twgl.createProgramInfo(gl, ['vs', 'fs'])
      gl.useProgram(progInfo.program)
      twgl.resizeCanvasToDisplaySize(gl.canvas)
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

      const arrays = {
        position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
      }

      function render(time) {
        const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays)
        twgl.setBuffersAndAttributes(gl, progInfo, bufferInfo)

        const uniforms = {
          u_time: time * 0.001,
          u_resolution: [gl.canvas.width, gl.canvas.height],
          u_aspect: gl.canvas.width / gl.canvas.height,
        }

        twgl.setUniforms(progInfo, uniforms)
        twgl.drawBufferInfo(gl, bufferInfo)
        requestAnimationFrame(render)
      }
      requestAnimationFrame(render)
    </script>
  </body>
</html>
